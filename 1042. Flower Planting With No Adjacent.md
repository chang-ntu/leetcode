# 题目

You have `N` gardens, labelled `1` to `N`. In each garden, you want to plant one of 4 types of flowers.

`paths[i] = [x, y]` describes the existence of a bidirectional path from garden `x` to garden `y`.

Also, there is no garden that has more than 3 paths coming into or leaving it.

Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers.

Return **any** such a choice as an array `answer`, where `answer[i]` is the type of flower planted in the `(i+1)`-th garden. The flower types are denoted 1, 2, 3, or 4. It is guaranteed an answer exists.

 

**Example 1:**

```
Input: N = 3, paths = [[1,2],[2,3],[3,1]]
Output: [1,2,3]
```

**Example 2:**

```
Input: N = 4, paths = [[1,2],[3,4]]
Output: [1,2,1,2]
```

**Example 3:**

```
Input: N = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]
Output: [1,2,3,4]
```

 

**Note:**

- `1 <= N <= 10000`
- `0 <= paths.size <= 20000`
- No garden has 4 or more paths coming into or leaving it.
- It is guaranteed an answer exists.

## solution

path数组给出了哪两个花园之间有路；现在有四种花需要种到花园里，要求有路相通的两个花园不能种同一种花。对每个花园建立字典，储存与它相邻的花园。

```python
class Solution:
    def gardenNoAdj(self, N: int, paths: List[List[int]]) -> List[int]:
        res = [0] * N
        dict = {}
        for i in range(1, N+1):
            dict[i] = {}
        for i, j in paths:
            dict[i][j] = 1
            dict[j][i] = 1
        for i in range(N):
            color = {1,2,3,4} - {res[x-1] for x in dict[i+1]}          
            if len(color)!=0:
                res[i] = color.pop()
        return res
```

